# `alarm_log`模块
## 引言

这个模块是一个用于处理警报日志的C++模块。它包含了一系列的函数，用于创建、写入、重命名和清理系统警报日志文件。

![alarm_log](D:\code\opengauss-server\src\lib\md\xmind\alarm_log.png)

---
## `logfile_open` 函数

该函数用于打开一个文件，并设置文件的权限和缓冲模式。

### 参数

- `filename`：要打开的文件名。
- `mode`：打开文件的模式。

### 返回值

- `FILE*`：指向打开的文件的指针。

### 功能

1. 设置文件权限掩码，允许文件所有者（用户）具有读、写和执行权限，同时保留组和其他用户的权限。
2. 使用指定的文件名和模式打开文件。
3. 恢复原始的文件权限掩码。
4. 如果文件成功打开，则设置缓冲模式为行缓冲。
5. 如果文件打开失败，则记录错误消息。
6. 返回打开的文件指针。

### 注意事项

- 在Windows上，使用`CRLF`换行符。
- 如果文件打开失败，将记录错误消息。
---
## `create_new_alarm_log_file` 函数

该函数用于创建一个新的告警日志文件。

### 参数

- `sys_log_path`：系统日志路径。

### 功能

1. 获取当前时间。
2. 将当前时间转换为格式化的字符串。
3. 创建临时日志文件名。
4. 创建新日志文件的完整路径。
5. 清空 `system_alarm_log_name` 缓冲区。
6. 将临时日志文件名复制到 `system_alarm_log_name`。
7. 使用 "追加" 模式打开新的日志文件。

### 详细说明

1. 初始化 `systm` 结构和 `log_create_time` 缓冲区。
2. 清空 `system_alarm_log` 缓冲区。
3. 获取当前时间。
4. 将当前时间转换为格式化的字符串，格式为 "-年-月-日_时分秒"。
5. 如果成功获取本地时间，则将格式化的时间字符串复制到 `log_create_time` 缓冲区。
6. 如果获取本地时间失败，则打印错误消息。
7. 创建临时日志文件名，格式为 "system_alarm-年-月-日_时分秒-current.log"。
8. 创建新日志文件的完整路径，将系统日志路径和临时日志文件名拼接而成。
9. 清空 `system_alarm_log_name` 缓冲区。
10. 将临时日志文件名复制到 `system_alarm_log_name` 缓冲区。
11. 使用 "追加" 模式打开新的日志文件，通过调用 `logfile_open` 函数实现。

### 注意事项

- 函数内部使用了一些辅助函数和宏定义，如 `memset_s`、`strftime`、`snprintf_s`、`strncpy_s` 等，请确保这些函数和宏定义的实现已经包含在代码中。
- 如果获取本地时间失败，则会打印错误消息，可以根据实际情况进行处理。

---

## `rename_alarm_log_file` 函数


该函数用于重命名告警日志文件。

#### 参数


- `sys_log_path`：系统日志路径。

#### 功能


1. 获取旧的告警日志文件名、后缀名和新的告警日志文件名的长度。
2. 将旧的告警日志文件名复制到 `logFileBuff` 缓冲区。
3. 在 `logFileBuff` 后追加 ".log" 后缀。
4. 创建新的告警日志文件的完整路径。
5. 关闭当前的告警日志文件。
6. 将当前的告警日志文件重命名为新的告警日志文件名。

#### 详细说明


1. 初始化 `len_log_old_name`、`len_suffix_name` 和 `len_log_new_name` 变量，分别表示旧的告警日志文件名、后缀名和新的告警日志文件名的长度。
2. 将旧的告警日志文件名复制到 `logFileBuff` 缓冲区，使用 `strncpy_s` 函数实现。
3. 在 `logFileBuff` 后追加 ".log" 后缀，使用 `strncat_s` 函数实现。
4. 创建新的告警日志文件的完整路径，将系统日志路径和 `logFileBuff` 拼接而成，使用 `snprintf_s` 函数实现。
5. 关闭当前的告警日志文件，如果 `alarmLogFile` 不为空，则使用 `fclose` 函数关闭文件。
6. 将当前的告警日志文件重命名为新的告警日志文件名，使用 `rename` 函数实现。如果重命名失败，则打印错误消息，并返回 false。

#### 注意事项


- 请确保旧的告警日志文件存在且可访问。
- 请确保新的告警日志文件路径指向一个有效的位置。

---

## `write_log_file` 函数


该函数用于将缓冲区中的数据写入告警日志文件。

#### 参数


- `buffer`：包含要写入的数据的缓冲区。

#### 功能


1. 获取写锁，以确保线程安全。
2. 检查告警日志文件是否已打开。
3. 如果当前的告警日志文件是 "/dev/null"，则创建一个新的系统告警日志。
4. 使用 "追加" 模式打开告警日志文件。
5. 将缓冲区中的数据写入告警日志文件。
6. 如果写入失败，则打印错误消息。
7. 刷新文件缓冲区。
8. 关闭告警日志文件。
9. 释放写锁。

#### 详细说明


1. 获取写锁，以确保在多线程环境下的线程安全性。
2. 检查告警日志文件是否已打开。如果 `alarmLogFile` 为空，则执行以下步骤：
- 如果当前的告警日志文件是 "/dev/null"，则调用 `create_system_alarm_log` 函数创建一个新的系统告警日志。
- 使用 "追加" 模式打开告警日志文件，通过调用 `logfile_open` 函数实现。
3. 将缓冲区中的数据写入告警日志文件。如果 `alarmLogFile` 不为空，则执行以下步骤：
- 获取缓冲区中数据的长度。
- 使用 `fwrite` 函数将数据写入告警日志文件。
- 如果写入的字节数与数据长度不一致，则打印错误消息。
4. 刷新文件缓冲区，以确保数据被写入文件。
5. 关闭告警日志文件，通过调用 `fclose` 函数实现。
6. 释放写锁，以允许其他线程访问。

#### 注意事项


- 请确保在多线程环境其他线程访问。

### 注意事项

- 请确保在多线程环境下使用适当的同步机制，如读写锁（`pthread_rwlock_wrlock`）来保护共享资源的访问。
- 在写入数据之前，确保告警日志文件已经成功打开。
- 如果告警日志文件打开失败或写入失败，请检查文件路径和权限，并确保文件系统可用空间充足。

---
## `create_system_alarm_log` 函数


该函数用于创建系统告警日志文件。

#### 参数


- `sys_log_path`：系统日志路径。

#### 功能

1. 打开指定路径的目录。
2. 遍历目录中的文件，查找当前的告警日志文件。
3. 如果找到当前的告警日志文件，则构建新的告警日志文件路径。
4. 如果未找到当前的告警日志文件，则创建新的告警日志文件。

#### 详细说明


1. 检查 `sys_alarm_log_path` 是否为空。如果为空，则将 `sys_log_path` 复制到 `sys_alarm_log_path` 中。
2. 打开指定路径的目录，使用 opendir 函数实现。如果打开目录失败，则打印错误消息，并将 `system_alarm_log` 设置为 "/dev/null"。
3. 遍历目录中的文件，使用 `readdir` 函数逐个读取目录项。
4. 检查当前的文件名是否包含 "system_alarm.log"，并且是否以 "CURLOGFILEMARK" 结尾。如果是，则表示找到了当前的告警日志文件。
5. 如果找到当前的告警日志文件，则清空 system_alarm_log_name 和 system_alarm_log 缓冲区。
6. 构建新的告警日志文件路径，将 `sys_log_path` 和文件名拼接而成，使用 `snprintf_s` 函数实现。
7. 将文件名复制到 `system_alarm_log_name` 缓冲区，使用 `strncpy_s` 函数实现。
8. 如果未找到当前的告警日志文件，则调用 `create_new_alarm_log_file` 函数创建新的告警日志文件。
9. 关闭目录，使用 `closedir` 函数实现。
---
## `clean_system_alarm_log` 函数

该函数用于清理系统告警日志文件。

### 参数

- `file_name`：文件名。
- `sys_log_path`：系统日志路径。

### 功能

1. 断言 `file_name` 不为空。
2. 获取文件的状态信息，使用 `stat` 函数实现。
3. 检查 `stat` 函数是否失败，或者文件名是否为 "/dev/null"。如果失败或者文件名为 "/dev/null"，则打印错误消息并返回。
4. 获取文件的大小。
5. 检查文件大小是否超过最大系统告警日志大小。
6. 如果文件大小超过最大系统告警日志大小，则获取写锁 `alarm_log_write_lock`。
7. 重命名当前文件，去除标记。
8. 如果重命名失败，则创建新的告警日志文件。
9. 释放写锁 `alarm_log_write_lock`。


---
## `write_alarm` 函数


该函数用于将告警信息写入日志文件。

#### 参数


- `alarmItem`：告警项。
- `alarmName`：告警名称。
- `alarmLevel`：告警级别。
- `type`：告警类型。
- `additionalParam`：额外的告警参数。

#### 功能



1. 检查 `system_alarm_log` 是否为空，如果为空则返回。
2. 初始化 `command` 和 `reportInfo` 缓冲区。
3. 检查告警类型是否为故障或事件。
4. 构建故障或事件告警的 `reportInfo` 字符串。
5. 将 `reportInfo` 写入日志文件。

#### 详细说明


- 函数首先检查 `system_alarm_log` 是否为空，如果为空，则直接返回，不进行后续操作。
- 接下来，函数初始化 `command` 和 `reportInfo` 两个缓冲区，用于存储命令和报告信息。
- 然后，函数检查告警类型是否为故障或事件。如果是故障或事件类型的告警，函数会根据提供的参数构建一个包含告警信息的 `reportInfo` 字符串。
- 最后，函数调用 `write_log_file` 函数，将构建好的 `reportInfo` 字符串写入日志文件。

#### 注意事项


- 在函数执行之前，需要确保 `system_alarm_log` 不为空，否则函数将直接返回。
- 函数使用 `command` 和 `reportInfo`  两个缓冲区来存储命令和报告信息，请确保这两个缓冲区的大小足够。
- 函数只处理故障和事件类型的告警，其他类型的告警将不会被处理。

## 总结

`alarm_log` 模块是一个用于处理系统警报日志的C++模块，旨在提供系统运行时的可靠性和故障排查的支持。模块中的关键函数包括 `logfile_open`、`create_new_alarm_log_file`、`rename_alarm_log_file`、`write_log_file`、`create_system_alarm_log`、`clean_system_alarm_log` 和 `write_alarm`。它们合作以创建、写入、重命名和清理系统警报日志文件。通过这些功能，`alarm_log` 模块为开发人员和系统管理员提供了一种有效的方法来监控系统状态和记录告警信息，以及进行故障排查。这有助于确保系统的稳定性和可维护性。